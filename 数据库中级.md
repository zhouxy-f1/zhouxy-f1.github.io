##  一、计算机系统基础

![image-20210405150239162](https://tva1.sinaimg.cn/large/008eGmZEgy1gp8vpnu6ulj30l30b50tx.jpg)

##### 硬件设备

```bash
硬件主要有：cpu（运算器+控制器+寄存器组+内部总线）、存储器（内存+外存，如硬盘、光盘、软盘等）、输入输出设备（键盘、鼠标、扫描仪、打印机等）

#考点
指令寄存器存放的是指令，程序计数器存放的是指令地址；算数逻辑单元的工作区是累加寄存器。
 
#运算器
运算器由控制器指挥工作，属于执行部件，主要负责完成计算机的算术运算（加减乘除求余取模等）和逻辑运算（与或非），组件如下：
1.算数逻辑单元(ALU, Arithmetic and Logic Unit): 负责处理数据，实现算术运算和逻辑运算
2.累加寄存器(AC, Accumulator): 为ALU提供工作区，给运算的中间结果和最后结果提供存放的空间
3.数据缓冲寄存器(DR, Data Register): 暂存从内存读取的一条指令或数据，用于缓冲内存与cpu速度差异，是cpu与内存、外设的中转站
4.状态条件寄存器(PSW, Program Status Word): 用于保存算术指令和逻辑指令或测试的结果建立的条件码，主要分为 状态标志和控制标志。这些标志通常分别由1位触发寄存器保存。如运算结果进位标志、运算溢出标志、运算结果为0标志、运算结果为负标志、中断标志、方向标志、单步标志等等

#控制器
它通过产生不同的信号控制整个CPU的工作，决定了计算机的运行过程，不仅保证程序正确执行，还要处理异常事件。控制器包括：指令控制逻辑、时序控制逻辑、总线控制逻辑、中断控制逻辑等部分；基本功能：取指、分析操作码并产生操作数地址、执行操作码和操作数形成操作信号、中断处理
1.指令寄存器(IR, Instruction Register): 存放从内存中读取的第一条'指令'
2.地址寄存器(AR, Address Register): 负责暂存当前CPU访问的'内存单元地址'，直至内存I/O操作完成，以防因内存和cpu操作速度不同引起的错误
3.程序计数器(PC, Program Counter): 存放将执行的下一条'指令地址'
4.指令译码器(ID, Instruction Decoder): 指令分为操作码和地址码两部分，ID主要就是负责对操作码部分进行解释，发出具体的控制信号

#总线分类
1.数据总线：cpu与内存或IO设备间双向交换数据
2.地址总线：cpu向内存单向发出地址信息
3.控制总线：cpu与内存或IO设备间传送控制信号，每次传送是单向
```

##### 执行指令

```bash
#指令
是对机器进行程序控制的最小单位，一条指令包括操作码和操作数，
指令示例：MOV R1 #45
操作码：指出是什么操作，MOV是操作数，由指令译码器来识别，
操作数：操作数本身或操作数所在地址，R1是地址 #45是常量
立即寻址：常量45在指令里
直接寻址：变量R1指向另一个地址
间接寻址：变量R1指向另一个变量，变量再指向地址

#执行指令
cpu执行指令分3步，例如 取指1ns，分析2ns，执行3ns，那么串行执行一条指令共需要1+2+3=6ns；串行效率低，所有采用流水线技术来并行执行。
即：只有第1条指令需要先取指，才能分析再来执行，所需时间是3个操作步骤总和，从第2条指令开始，三个步骤并行，所需时间取决于耗时最长的步骤，所以周期为耗时最长的步骤所需时间
则：流水线执行时间 T=第1条指令执行时间+(总指令数-1)*流水线周期，那么执行100条指令所需时间=（1+2+3）+（100-1）*3=303ns
				第1条				第2条		第3条
取指	|———				|———	 |———	 	|
分析	|		——————	|——————|——————|
执行	|					——|		 ——|	  ——|

#吞吐率
实际吞吐率: 单位时间内执行的指令总数。如：吞吐率=指令总条数/总耗时=100/303
最大吞吐率:最长流水段操作时间的倒数。如：取指需1ns,分析2ns，执行3ns，则最大吞吐率为1/3
```

##### 进制转换

```bash

2、8、16进制 ==按权展开法==>  10进制   ==整除取余法==> 2、8、16进制
16进制0~9 ABCDEF

#进制表示方法
二进制：1001(2)或10010B
八进制：1007(8)或1007O
十进制：1009(10)或1009D
十六进制：1C0F(16)或1C0FH

#任何进制转十进制（按权展开法）
256.3(O)=2*8的2次方+5*8的1次方+6*8的0次方+3*8的负1次方=128+40+6+0.375
6F8A(H)=6*16的3次方+15*16的2次方+8*16的1次方+10*16的0次方

#十进制转任何进制（整除取余法）
	2|_____17_
	 2|_____8_		=>1 
	  2|____4_		=>0
	   2|___2_ 		=>0
     	2|__1_		=>0
     			0			=>1

#八进制十六进制转二进制
1.八进制转二进制：把八进制的所有位分别转成3位二进制数，如： 357(O)= 011 101 111
2.十六进制转二进制：把十六进制的所有位分别转成4位二进制数据，如： A6F= 1010 0110 1111
```

##### 校验码（ 不考了）

```bash
#奇偶校验码
分为奇校验和偶校验，通过在编码的最前或最后面增加一个0或1使编码中1的个数为奇数（奇校验）或偶数（偶校验），奇校验可以发现奇数位出错，不能发现哪个奇数位出错，且不可发现偶数位出错

#海明码
设：编码有n位，最少需要k个校验码，其关系是： (2^k)-1>=n+k
例：编码有16位，需要满足(2^k)-1>=16+k关系，k的最小值6，所以16位编码最少需要6个校验码

#CRC循环冗余校验码
通过异或算法，相异为真，用1表示；相同为假，为0表示
```

##### 高速缓存（常考）

```bash
#高速缓存
高速缓存主要是用于调和cpu与内存间速度差，存放的是当前最活跃的程序和数据，分为一级缓存二级缓存，一缓集成在CPU内部，二缓集成在主板上。容量一般几千字节到几兆，速度比内存快5-10倍，由快速半导体存储器构成，其内容是主存局部域的副本，对程序员是透明的 
工作原理：当CPU需要读取数据时，先判断要访问的信息是否在Cache中，如果在即为命中，如果不在就要按替换算法把内存中信息调入Cache中，替换算法有随机替换算法、先进先出替换算法、近期最少使用替换算法、优化替换算法
系统处理数据时间=(高速缓存命中率)*高速缓存处理时间+(缓存未命中率)*内存处理时间

#地址映像
由于CPU读取数据的指令里地址是内存地址，要让CPU能从Cache中读取信息，就需要将内存地址转换为Cache地址，即地址映像

1.直接映像
把内存分为m个区，每个区的大小要跟Cache总的大小相等；把Cache分为n个块，把内存中各个区也分成n个块，跟Cache中的块一一对应，这种对应关系是固定的
优点：由于内存的块只能存放在Cache中相同的块号中，通过内存中的块号直接在Cache中就能找到，访问速度快
缺点：块的冲突率高，Cache使用率低
内存地址为：内存区号+区内块号+块内地址

示例：设主存容量为1MB，高速缓存容量为16KB，块的大小为512B，块内地址为8位，求内存地址需要多少位？
内存分多少个区 => 1MB/16KB =  64个区		-->需要6个位来表示
每区分多少个块 => 16KB/512B = 32个块		-->需要5个位来表示

结果：内存地址有 6+5+8=19位

2.全相联映像
先把Cache平均分成m个块，内存不再分区，而是按cache块容量大小平均分为n个块，允许内存的任意块可以调入Cache中的任何一个块空间，这样更灵活，块冲突率低，但内存的块号跟Cache中的块号不是一一对应的，其对应关系就需要单独记录，变换复杂，速度慢，成本高
内存地址：主存块号+块内地址

3.组相联映像
吸取直接映像和全相联映像的优点，先把Cache平均分成m个组，组内平均分n个块，然后内存分区，区的大小等同Cache容量总大小，每个区跟Cache一样分组分块
缓存的组跟内存的组采用直接映像方式，块之间采用全相联映像方式。即：cache中的组跟内存中的组一一对应，cache中组内的块跟内存中组内的块随便放
例:内存中的15组只能放到Cache的15组，内存中15组的任何块都可调入Cache15组的任何块

内存地址位数=区号+组号+主存块号+块内地址
Cache地址拉数=组号+组内块号+块内地址
```

##### 编址

```bash
存储器是由一个个存储单元构成的，为了对存储器进行有效的管理，就需要对各个存储单元编上号，即给每个单元赋予一个地址码，这叫编址。
内存是按字节编址的，即每个字节都有一个编号，若某存储器有n个编号则该存储器容量有n个字节

举例：
地址编号从80000H到BFFFFH且按字节编址的内存容量为（ ）KB，若用16K*4bit的存储器芯片构成该内存，共需要（ ）片？

解答：
先求总共有多少个编址： BFFFF-80000+1=40000H个地址；换算为10进制则有4*16^4个地址
再求容量有多少：由于是按字节编址，即每个地址代表1byte的容量，则共有4*16^4byte的容量
最后把byte换算成KB：即2^8KB=256KB，所以内存容量为256KB
求多少片：256KB/(16K*4b)=32片
```

##### 输入输出技术（常考）

```bash
#程序控制方式
1.无条件传送：外设总是准备好的，无条件地随时接收和提供数据
2.程序查询方式：CPU利用程序来查询外设的状态，如果外设没准备好，cpu就需要等外设准备好了再传数据
3.中断方式：CPU不等待也不执行程序去查询外设状态，当外设准备好了后直接向CPU发送中断请求，cpu收到请求暂停手上的活并保存现场再来处理外设的请求
4.DMA方式(常考)：直接内存存取方式，由DMA硬件在内存与外设间建立数据通道，直接执行输入输出，不需要CPU干预，但传输开始和结束时会发信号给cpu
5.通道方式和外围处理方式：增加硬件（通道处理机），完全接管CPU对输入输出的控制

#总线分类
数据总线(Data Bus,DB): 在CPU与内存外存之间传输数据，是双向的
地址总线(Address Bus,AB): 用于传送CPU发出的地址信息，是单向的，地址总线的宽度决定了CPU最大寻址能力
控制总线(Control Bus,CB): 用来在CPU与内存外设间传送控制信号、时序信号、状态信息等
```

##### 存储系统

```bash
计算机中的存储设备按速度排列：寄存器>高速缓存>内存>硬盘

#存储器分类
按构成材料分类：磁存储器、半导体存储器、光存储器
按工作方式分类：读写存储器、只读存储器
按访问方式分类：按地址访问的存储器（如cache、内存等）和按内容访问的存储器（比如相联存储器）
按寻址方式分类：随机存储器、顺序存储器和直接存储器

#计算存储器容器
1.计算磁盘容器
磁盘容量=有效盘面数*每盘面的磁道数*每个磁道的容量
·磁盘由n个盘片组成，每个盘片有两个面，但磁道最上和最下的盘面不存数据，所以有效盘面为2n-2个
·磁道数=直径*道密度【沼直径方向，单位距离的磁道数量，如30个磁道/cm】
·磁道容量=任一磁道的周长*该磁道的位密度【每个磁道上单位距离可记录的位数，如100bit/cm】
·磁道容量=任一磁道的扇区数*每个扇区容量
注：每个扇区内可存放的数据块大小是相同的，每条磁道记录相同大小的数据量

2.计算内存容量
内存容量=芯片个数*芯片容量=芯片个数*编址总数*每个地址的容量
·每个地址的容量，取决于编址方式，如果按字节编址则每个地址占1byte，如果按字编址则每个地址占一个字长
·字长：处理机能同时处理（或运算）的位数，即同时处理多少位（bit）；也即它的地址总线位32位
·地址总数=末位编号-首位编号+1，比如从0~19，共有19-0+1=20个数
```

##### 安全可靠性（常考公式）

```bash
#分类和定义
1.对称加密：对文件的加密和解密使用相同的密钥，代表算法DES(替换和移位算法,56位)、3DES(2个56位密钥)、IDEA(128位)、AES(基于排列和置换运算)
2.非对称加密：分为公钥和私钥，成对出现，公钥加密只能用配对的私钥来解密，私钥加密也只能用配对的公钥来解密，非对称加密有两种体制
	a.加密模型: 公钥给别人，让别人用这个公钥加密信息，自己收到信息用私钥解密，保密性好，但由于公钥会推送给很多人，无法识别加密信息是谁发过来的
	b.认证模型: 我用私钥加密，发加密文件给别人，别人用我的公钥解密，能解开则确认加密文件是我发的。这种保密性不好，因为有公钥的人都能解密我的信息

#加密模型
1.数字签名模型(认证模型)
发送者A把信息用MD5得到摘要，再把摘要用自己的私钥加密，把信息和加密后的摘要一起发给接收者，接收者B收到信息和摘要后，先把摘要进行MD5算法得到摘要，再用A的公钥解密A传过来的摘要，对比这两个摘要是否一致，一致则表示信息未被修改过。如果无法用公钥解密则说明B收到的信息和摘不是A发过来的

2.数字加密模型（加密模型）
传送者A把信息先对称加密，再用接收者B的公钥把对称密钥加密，完成后发送给B，B用私钥解密出对称密钥，再用密钥来解密信息

注：
'数字签名是用自己的私钥加密，数字加密是用别的人公钥加密'
信息摘要是把文件或信息用MD5算法产生的128位字符串，文件或信息只要未改动，其信息摘要是不会变的；
数字签名与数字加密的区别是数字签名可确认发送者身份，保密性不好，数字加密保密性好但不能确认身份

#计算机可靠性（公式很重要，）
可靠性指能正常工作的概率
串联系统的可靠性：R=R1*R2*R3*Rn
并联系统的可靠性：R=1-(1-R1)*(1-R2)*(1-Rn) 	【(1-R1)是R1坏掉的概率，即：可靠性=1-所有系统全坏的概率】
```

##### 多媒体基础（不考了）

```bash
#多媒体分类
感觉媒体：作用于人体的感觉器官，如声音、视频、图像
表示媒体：用于数据交换的编码，如JPEG图像编码、ASCII文本编码等
表现媒体：用于信息输入输出的媒体，如键盘、鼠标、显示器等
交换媒体：用于进入数据交换，包括存储媒体（如硬盘光盘）和传输媒体（如电缆，光纤等）

#声音信号数字化
声音信号是一种模拟信号，需要转换为数字信号才能被计算机处理，这个过程就是数字化，分三步骤
采样：采样频率=1/周期采样，采样频率需要大于声音信号最高频率的2位才能保证声音不失真
量化：二进制数的位数反应量化精度，位数越多则精度越高
编码：按一定的格式进行编码组织成文件

#图像
1.分辨率
显示器分辨率：指显示器能够显示图像的区域大小，如1024像素*768像素。当图像分辨率大于显示器分辨率时，该图像在显示器上不能完整显示
图像分辨率：指组成一幅图像总的像素数量，如400*500像素。图像扫描精度用dpi(dots per inch)表示，如200dpi就是每英寸有200个像素

设：用200dpi来扫描一幅2*2.5英寸的彩色照片，可得到多少像素的图像？
解：（200dpi*2英寸）*（200*2.5英寸）=400*500像素

2.计算图像大小
图像大小=图像总像素*像素深度(单位bit)
像素深度：每个像素用多少个二进制位表示，如像素深度为8，则每个像素占8bit的大小，此时每个像素可表示2^8=256种颜色

设：一幅640*480的256色图像，其数据量为多少？
解：数据量=像素量*每个像素大小=640*480*8bit=300KB

640*480*8bit		640*480*8bit		 640*480		（2^6）*10*(2^3)*60			600
————————————  = ————————————— = ———————— = ———————————————————— = ————— = 300KB
		KB						1024*8bit				1024						2^10							2
```

## 二、程序语言基础

##### 程序定义

```sh
#程序语言的定义
1.低级语言: 机器语言指0和1组成的机器指令
2.汇编语言: 汇编语言是用符号来代替0和1，符号指令的集合就是汇编语言,比如：10001001 1101 1000 等价于 MOV  AX, BX
2.高级语言: 面向各类应用的程序语言，如java、c、C++、python等，可读性好但执行效率不如低级语言


#程序语言基本成份
1.数据：常量变量、全局局部变量、数据类型
2.运算：算术运算、关系运算、逻辑运算
3.控制：顺序、选择、循环
4.传输：

#编译与解释
由于计算机不能识别高级语言，需要通过汇编、解释、编译等方式翻译成机器语言，才能识别并执行
汇编：把汇编语言写的程序用汇编程序翻译成目标程序
解释：边解释代码，边执行，解释一行，执行一行，不产生目标代码
编译：把源程序编译成目录程序后，再单独执行目标程序，一次编译多次执行，效率更高
```

##### 代码编译

```bash
#编译过程
编译过程分6个阶段，前4个阶段与使用的高级语言相关，可称为编译的前端；后2个阶段与执行代码的机器相关，称为后端，这6个阶段同步执行符号表管理和出错处理

1.词法分析：分析单词，对源程序从前到后从左到右，逐个字符地扫描，识别出关键字、标识符、常数、运算符、标点符号、括号等
2.语法分析：分析语句形式，在词法分析基础上，分析单词串是否构成合法的表达式、语句、程序等，检查出语法错误，无误则生成语法树
3.语义分析：分析语句含义，主要是检查数据类型及类型的运算上，比如整除取余运算如果包含了浮点数，则报错
4.中间代码生成：常见中间代码有后缀式（逆波兰式）、四元式（三地址码）、树形等
5.中间代码优化：由于按固定模式生成的中间代码效率较差，需要优化才能高效
6.目标代码生成：把中间代码转换成机器能识别的指令代码，执行代码的机器不同，指令也不尽相同

#符号表与语法树
编译过程中，确认了源程序的语法和语义后，开始翻译工作
翻译声明语句：是把所有遇到的标识符、类型、地址组成符号表，符号表每行的内容是：符号 类型 分配多少存储单元
翻译可执行语句：检查语法分析阶段生成的语法树是否合理，比如数据类型隐式转换等

#生成中间代码
源代码中都是用的中缀表达式（即运算符号写在中间），常需要使用前缀表达式（运算符号写在操作数的前面，且不用括号，又称波兰式），或者后缀表达式（符号在后面，没有括号，称为逆波兰式）

1.中缀表达式转为前缀表达式
例：(a+b)*c-d
第一步：按'计算'顺序添加括号  					{[(a+b)*c]-d}
第二步：把每对括号内的运算符移到括号前	  -{*[+(ab)c]d}
第三步：去掉括号										 -*+abcd

2.中缀表达式转为后缀表达式
第一步：按计算顺序添加括号  						{[(a+b)*c]-d}
第二步：把每对括号内的运算符移到括号后		{[(ab)+c]*d}-
第三步：去掉括号											ab+c*d-

3.前缀表达式转为中缀表达式（新课程没讲）
从右到左扫描后缀表达式，若遇到运算对象则压入栈中，遇到运算符则从栈中弹出最上面的两个对象，把结果再压入栈中，直到结束
4.后缀表达式转为中缀表达式
从左至右扫描前缀表达式，基遇到运算对象则压入栈中，遇到运算符则从栈中弹出最上面的两个对象，把结果再压入栈中，直到结束
```

## 三、数据结构与算法

##### 线性结构

```bash
数据是数据元素的集合，各元素间的相互关系称为逻辑结构，逻辑结构分为线性结构和非线性结构。数据元素和元素间关系的存储形式称为存储结构，分为顺序存储与链接存储
线性结构：线性表、栈、队列、串
非线性结构：树、图

#线性表的存储结构
线性表是由n个元素组成的有限序列，线性表的存储结构包括顺序存储和链式存储，按顺序存储的线性表叫顺序表，按链接存储的线性表叫链表

1.顺序表
用一组连续的存储单元依次存储线性表中的各元素，每个元素的序号与物理地址一一对应，通过序号查数据很快，但插入删除都要移动其他的元素

2.链表
各元素通过申请节点空间来存储，节点空间=数据域+指针域，指针域指向下一个节点的地址。第一个元素的地址没有对应的指针，那在第一个节点前面增加头节点（空数据+指向第一个元素所在节点地址），再用头指针Head指向头节点。链表中数据的存储是随机的，因为有指针能找到下一个节点，插入删除数据都不需要移动元素，但查找第n个元素就需要从头开始找。

a.单链表：节点中只有一个指针域
b.循环链表：最后一个节点原本是（最后一个数据，空指针），把空指针批向Head，这样首尾相连就是循环链表
c.双链表：每个节点空间增加一个指针指向前面的元素，如（前驱节点的指针+数据+后继节点的指针）

链表插入删除节点的计算？

#栈
按后进先出的规则进行，

1.顺序栈
顺序栈是用一组连续的地址依次存储从栈顶到栈底的元素，顺序栈的空间需要提前申请，用head指针来标识最后一个地址空间，加入第1个元素用bottom指针，第2个元素用top指针，后面每加入一个元素，把top指针往上移动，来指向最新的元素，当top与head相等时，说明栈空间满了

2.链栈
用链表（申请空间=数据+指针）存储栈中的元素，空间都是有数据才临时申请，不需要提前申请空间，空间不会满，也不需要用head指针。压入栈的第1个节点是（元素1+空指针），第2个节点是（元素1，节点1的地址），再把top指针指向栈顶的节点，


#队列



```

## 四、操作系统

##### 定义

```bash
#操作系统
管理软硬件资源，控制程序执行，提交人机交互的接口
作用：通过资源管理提高系统效率，提供友好的交互界面
特征：并发性、共享性、虚拟性、不确定性
功能：进程管理、文件管理、存储管理、设备管理、作业管理
```

##### 进程管理

```bash
#进程状态
运行：当进程在处理机上运行时，单处理机只有一个正在运行状态的进程
就绪：具备除了处理机外的所有资源，正在等待处理机
阻塞：进程正在等待某事件发生


```

## 五、网络基础

```bash

```

## 六、关系数据库

##### 数据库基础

```bash
#三级模式
物理层：对应内模式，包括索引和存储文件
逻辑层：对应模式，包括基本表
视图层：对应外模式，包括视图（存储的是sql语句，并非基本表）

#两级映象
数据的物理独立性：当内模式改变时，保持逻辑结构不变，通过修改概念模式\内模式之间的映像实现
数据的逻辑独立性：当逻辑结构改变时，不需要改程序代码，通过外模式\概念模式之间的映像实现，即重建视图

#ER图
数据模型：用于定义数据的，包括数据结构、数据操作、数据约束
方框：表实体
双方框：表弱实体，依赖实体存在
椭圆：表属性
菱形：表关系，如授课、选修、参加、领导等
实线：连接实体与属性，1对多，多对多，1对1
两根实线：连接一个实体与一个属性，没有第二个实体
```

##### 关系数据库

```bash
#关系相关名词
属性：字段，用于描述表
域：字段的取值范围，如varchar，男女
候选码（简称：码）：唯一键
主属性：所有的唯一键
主码：主键
全码：所有字段（属性）
外码：有字段跟本表无关，但该字段是其它表中的主键

#关系的三种类型
1.基本关系: 基本表，实际存储数据的逻辑表示
2.查询表: 查询结果对应的表
3.视图表: 虚表，是由基本表或视图导出的表，数据库中实际只存放其定义

#关系模式
指对关系的描述，用R(U,D,dom,F)表示，R是关系名,U是所有属性，D是属性的域，dom是属性向域的映像集全，F是属性间依赖关系
用下划线表示主键，联合主键是把多个主键逗号隔开，一起加下划线；虚下划线表示外键


示例：
Student(Sno,Sname,SD,Sex)
Course(Cno,Cname,PCno),Dom(Pcno)=Cno		#PCno是先行课程号，来自Cno的域，用Dom来定义
SC(Sno,Cno,Grade)

#关系的完整约束
1.实体完整性: 主属性（唯一键）不可为空
2.参照完整性: 若表A中有外键是表B的主键，那么外键的值必须存在于主键中
3.用户定义完整性: 字段的取值必须在用户定义的范围内，比如规定最低工资是2000，就不可以出现少于2000的工资
```

##### 关系运算

```bash
1.并运算
就是取两张关系表的合集，记作R∪S。要求两张关系表的字段及字段数据类型、取值范围必须相同。结果是两张表的记录合并后去掉重复的记录

2.交运算
就是取关系表R和S中都有的记录，记作R∩S。要求R与S有相同的关系模式

3.差运算
关系R与S的差是由属于R但不属于S的元组集合，记作R-S，同样也要求有相同的字段和数据类型

4.广义笛卡儿积
关系R与S的迪卡儿积用R*S表示，RxS的列是R的列加S的列，再用R的第一条记录对应S的所有记录，第二条记录也对应S的所有列，以此类推

5.投影运算与广义投影运算（对列的运算）
投影运算就是从关系R中取若干列组成新的关系，记作兀a(R)，a是选取的列，可选多个用逗号隔开；如兀a,b(R)，ab也可做运算，称为广义投影运算

6.选择运算（对行的运算）
表示为δf(R)，δ表示选择运算，f表示运算关系，包括大于、小于、交、并、非、6、'6'，其中6表示第6列，'6'表示数字6

δ1>6(R)表示：选择R关系表中第1列大于第6列的所有行
δ1>'6'(R)表：选择R关系表中第1列大于6的所有行

7.连接运算
连接运算有3种，θ连接、等值连接、自然连接
θ连接：从笛卡儿积中做δ选择运算，记作R∞S/aθb，其中θ为等于、不等于、大于、小于等比较运算符，等价于δaθb(RxS)
等值连接：当θ为等于号的时候，此连接运算称等值连接
自然连接：在等值连接的基础上，R与S中相同的字段都要做等值连接，再去掉重复的列，用R∞S表示

8.除法运算

9.外连接运算
外连接是为弥补自然连接的不足，如表R中有，表S中没有的值，此时R表中会有部分信息缺失，无法通过连接运算找出哪些信息是缺失的
a.左外连接：是在自然连接基础上，再列出左表中没有出现在自然连接的记录，右表里没有的对应的值就用NULL填充
b.右外连接：是在自然连接基础上，再列出右表中没有出现在自然连接的记录，左表里没有的对应的值就用NULL填充
c.全外连接：取左外连接跟右外连接的并集

#常考点：关系运算的等价转换
```

![image-20201022222517465](https://tva1.sinaimg.cn/large/0081Kckwgy1gjyh9ihi97j30q20cvtb2.jpg)

##### 规范化

```bash
#规范化

将低一级范式的关系模式分解成多个高一级范式的关系模式称为规范化，各范式间关系是：4NF ∈ BCNF ∈ 3NF ∈ 2NF ∈ 1NF
即：第一范式包含第二范式，第二范式包含第三范式，以此类推

#详解各范式
'1NF,第一范式': 指关系表中没有多余的列，每一列都不可再分割，如学生表（学号，姓名，信息）中，字段信息包括地址和电话等，就需要把字段信息拆分为地址和电话才满足第一范式，不满足第一范式的不能叫关系型数据库。缺点：数据冗余、更新异常、删除异常、插入异常

'2NF,第二范式': 在第一范式基础上，去掉了跟关系表中各字段都无关的列，关系表中的非主属性必须完全依赖于本表的码，比如学生表（学号，姓名，学院编号，学院名称）满足第二范式，因为非主属性姓名和学院编号取决于学号，学院名称取决于学院编号

'3NF,第三范式': 在第二范式基础上，各非主属性不依赖唯一键。如学生表（学号，姓名，学院编号，学院名称）中，学院编号能决定学院名称，这就不是第三范式，该表拆分为学生表1（学号，姓名，学院编号）和学生表2（学号，学院编号，学院名称）

'BC范式': 在第一范式基础上，所有属性都不依赖与唯一键


'4NF,第四范式': 
```

##### 事务

```bash
#数据库故障类型
系统故障：操作系统软硬件的损坏，事务还在内存没写到磁盘，可通过binlog把提交的事务做REDO，把未提交的做UNDO
介质故障：存储的磁盘损坏，存储文件全没了，就需要用备份和日志一起来恢复
事务故障：事务内部逻辑错误（非法输入、0当除数等）和系统错误（如死锁）

#事务的特性
原子性：要么全执行完，要么全不执行
一致性：状态一致
隔离性：不同事务互不影响
持久性：commit后写入磁盘

#事务调度
串行调度：是多个事务依次执行，当一个事务提交完才执行另一个事务，有N个事务就有N种正确的串行调度
并发调度：分时处理N个事务，只有并行结果跟串行结果相同时，才算是正确的调度

#并发调度带来的问题
丢失修改：
不可重复读：事务T1读取了数据A后，事务T2修改了数据A，当事务T1再读数据A时，跟第一次读的结果不一致
脏读：事务T1读到的数据被事务T2回滚了
幻读：事务T1搜索到杭州剩余100张票，事务T2新增了20张票，当事务T1再搜索时，发现剩余票有120张了

#并发控制
并发事务如果对数据读写不加控制，就会破坏事务的隔离性和一致性，可通过加锁实现互斥方式访问数据，常见锁有两种：
1.排它锁(写锁，X锁):事务改数据前先加X锁，当前事务对该数据可读可写，其它事务不可读也不可写，也不可再对该数据加任何锁
2.共享锁(读锁，S锁):事务读数据前先加S锁，当前事务只能读该数据不能改，其它事务对该数据可加S锁来读，但不能加X锁来改

#可串行化调度与两段锁协议
可串行化调度是指多个事务的并发执行结果与某次串行执行结果相同时，这种并行调度策略就是可串行化调度，可串行化调度是判断事务正确性的准则。为保障串行化，需要遵循两段锁协议，即：同一事务在对数据进行读写操作之前必须先加锁，操作完毕释放锁后不能再申请锁，如下T1遵循了两段锁协议，遵循了两段锁协议的调度一定是可串行化的调度，但两段锁协议可能产生死锁。
T1: SlockA SlockB	 XlockC UlockB UnlockA UnlockC
T2: SlockA UnlockA SlockB XlockC UnlockC UnlockB

#事务隔离级别
为解决读一致性的问题
RU读未提交 > 最低级别，不能解决并发带来的问题
RC读已提交 > 可避免脏读（读到被回滚的数据）
RR可重复读 > 默认级别，可避免脏读与不可重复读
S串行化    > 最高级别，可避免脏读、不可重复读、幻读


```















